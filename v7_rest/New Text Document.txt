/**
 * Upload a file directly to Salesforce as ContentVersion using multipart/form-data.
 * Supports files up to 2 GB because it uses binary streaming (no base64, no Apex).
 */
async uploadAsContentVersion(file, firstPublishLocationId) {
    const entity = {
        Title: file.name,
        PathOnClient: file.name,
        FirstPublishLocationId: firstPublishLocationId
    };

    const form = new FormData();
    
    // JSON metadata part
    form.append(
        'entity_content',
        new Blob([JSON.stringify(entity)], { type: 'application/json' })
    );

    // Binary file part (IMPORTANT: no base64, no encoding)
    form.append('VersionData', file, file.name);

    // Use relative URL so Salesforce session cookies are automatically included
    const res = await fetch('/services/data/v66.0/sobjects/ContentVersion', {
        method: 'POST',
        body: form
        // DO NOT set Content-Type. FormData sets the multipart boundary for us.
        // DO NOT set Authorization header. Browser cookies authenticate the call.
    });

    if (!res.ok) {
        const errorText = await res.text();
        console.error('Upload failed:', errorText);
        throw new Error(errorText);
    }

    return res.json();   // Contains { id, success, errors } and ContentDocumentId sub-object
}

////////////

// Upload original .MSG file
const msgFile = this.template.querySelector('lightning-input[type="file"]').files[0];
await this.uploadAsContentVersion(msgFile, emailId);

//////////////

Replace your old Apex uploadAttachment loop with this:
==>


/**
 * Replaces old Apex-based uploadAttachment logic.
 * This version uploads each MSG attachment directly to Salesforce using multipart/form-data.
 * Supports up to 2 GB because it avoids base64 and avoids Apex heap limits.
 */
async uploadAttachmentsSequentially(msgReader, attachments, emailId) {
    const total = attachments.length;

    for (let i = 0; i < total; i++) {

        const attMeta = attachments[i];
        const attObj = msgReader.getAttachment(i);

        const currentNum = i + 1;
        this.progress = 30 + Math.floor((currentNum / total) * 60);
        this.statusText = `Uploading attachment ${currentNum} of ${total}: ${attMeta.fileName || 'Untitled'}`;

        // Skip attachments with no content
        if (!attObj || !attObj.content) {
            console.warn(`Skipping empty attachment at index ${i}`);
            continue;
        }

        // Convert MSG attachment buffer into a real File object (binary-safe)
        const fileName = attMeta.fileName || `attachment_${i}`;
        const mimeType = attMeta.contentType || "application/octet-stream";

        // attObj.content may be a Uint8Array â€” normalize to ArrayBuffer
        const arrayBuffer = attObj.content.buffer
            ? attObj.content.buffer
            : attObj.content;

        const blob = new Blob([arrayBuffer], { type: mimeType });
        const file = new File([blob], fileName, { type: mimeType });

        // Upload via REST multipart/form-data (2 GB support)
        await this.uploadAsContentVersion(file, emailId);
    }
}
